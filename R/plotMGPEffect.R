#' Human MGP
#' 
#' Generates associated MGP effects from "runHumanMGP" output 
#' 
#' @param obj humanMGP object (output generated by runHumanMGP function)
#' @param comp Which PLS component to visualize (default = 1)
#' @param sdy Standard deviation of the yscores. sdy=3 will show the effects of -3sd vs +3sd (default = 3)
#' @param lambda Regularization parameter of the TPS (only valid for sparse landmarks; default = 1e-8)
#' @param ncores Number of CPU cores to be used for parallellization (default = 1)
#' 
#' @return 
#' \item{predmax }{Predicted MGP effect at +sdy standard deviations from the mean}
#' \item{predmin }{Predicted MGP effect at -sdy standard deviations from the mean}
#'
#' @author Hanne Hoskens
#' 
#' @export
plotMGPEffect <- function(obj, comp, sdy, lambda, ncores){
  
  if (missing(comp)) { comp = 1 }
  if (missing(sdy)) { sdy = 3 }
  if (missing(lambda)) { lambda = 1e-08 }
  if (missing(ncores)) { ncores = 1 }
  
  nsplandmarks = 65
  
  nlm = dim(obj$PLS$y)[2]

  # Sparse
  if (nlm == 3*nsplandmarks) { 
    mesh = Morpho::file2mesh("/mnt/BHServer4/FaceBase_3/Data/Images/Atlas/Dense_2k_ears/dense_2k_ears_atlas.ply")
    ind_sparse = read.csv('/mnt/BHServer4/FaceBase_3/Data/Images/Atlas/Dense_2k_ears/sparse_65_ind.txt',header=F);
    sparse_lm = mesh$vb[1:3,as.matrix(ind_sparse)]
    
    avg = colMeans(obj$PLS$y)
    
    plsEffects = plsCoVar(obj$PLS, i=comp, sdy=sdy)
    predminlm = matrix((avg + plsEffects$y[1,]),3,nsplandmarks)
    predmaxlm = matrix((avg + plsEffects$y[2,]),3,nsplandmarks)
    
    # Transform sparse to dense
    out = list()
    out$predmin = tps3d(mesh,t(sparse_lm),t(predminlm),lambda=lambda,threads=ncores)
    out$predmax = tps3d(mesh,t(sparse_lm),t(predmaxlm),lambda=lambda,threads=ncores)
  }
  
  return(out)
  
}
